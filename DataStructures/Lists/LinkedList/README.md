# Связный список (Linked List)

## Введение

Связный список — это динамическая структура данных, состоящая из узлов (nodes), где каждый узел содержит значение и ссылку на следующий узел в последовательности. В отличие от массивов, связные списки не требуют выделения памяти заранее, что делает их удобными для работы с динамически изменяемыми данными.

Связные списки широко применяются в компьютерных науках, включая реализацию динамических структур данных, систем управления памятью, построение графов и обработку больших объемов данных, где важны операции вставки и удаления.

## Основные операции в связном списке

Связный список поддерживает следующие основные операции:

### 1. `GetNewList()`
Создает и возвращает новый пустой связный список.

### 2. `Append(value interface{})`
Добавляет элемент в конец списка.
- Временная сложность: **O(1)**

### 3. `Prepend(value interface{})`
Добавляет элемент в начало списка. 
- Временная сложность: **O(1)**

### 4. `InsertAt(position int, value interface{}) error`
Вставляет элемент в указанную позицию. 
- Временная сложность: **O(n)**

### 5. `Remove(position int) error`
Удаляет элемент по индексу. 
- Временная сложность: **O(n)** (так как требуется пройти до указанного индекса).

### 6. `Find(value interface{}) (*ListNode, bool)`
Ищет узел по значению. Возвращает указатель на узел и `true`, если элемент найден.
- Временная сложность: **O(n)**.

### 7. `GetAt(position int) (*ListNode, error)`
Возвращает значение узла по индексу. Если индекс некорректен, возвращает ошибку.
- Временная сложность: **O(n)**.

### 8. `GetLength() int`
Возвращает количество элементов в списке.
- Временная сложность: **O(1)**

### 9. `Reverse()`
Разворачивает список в обратном порядке.
- Временная сложность: **O(n)**.

---

## Преимущества и недостатки связного списка

### **Преимущества**:
1. **Динамическое выделение памяти** – связный список не требует заранее выделенного фиксированного размера, в отличие от массива.
2. **Быстрое добавление и удаление элементов** – добавление в начало или конец списка выполняется за **O(1)**.
3. **Эффективное использование памяти** – нет необходимости выделять память заранее, узлы создаются по мере необходимости.

### **Недостатки**:
1. **Медленный доступ по индексу** – для получения элемента требуется пройти весь список **O(n)**, в отличие от массива, где доступ по индексу выполняется за **O(1)**.
2. **Дополнительные затраты памяти** – каждый узел требует хранения указателя на следующий элемент.
3. **Неэффективный кеш-памяти** – из-за разрозненного расположения узлов в памяти работа со связным списком может быть медленнее по сравнению с массивами.

---

## Когда использовать связный список?

### **Рекомендуется использовать, если**:
- Требуется **частая вставка и удаление элементов**, особенно в начале списка.
- Размер структуры **динамически изменяется**, и его сложно предсказать заранее.
- Нужно **минимизировать перераспределение памяти**, так как в массиве увеличение размера требует выделения нового блока памяти и копирования данных.

### **Не рекомендуется использовать, если**:
- Часто требуется **доступ по индексу** – массивы значительно быстрее.
- Важна **оптимизация использования памяти** – массивы занимают меньше памяти за счет отсутствия указателей.
